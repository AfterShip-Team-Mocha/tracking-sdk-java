/*
 * This code was auto generated by AfterShip SDK Generator.
 * Do not edit the class manually.
 */
package com.aftership.http;

import com.aftership.constant.ErrorEnum;
import com.aftership.exception.ApiException;
import org.apache.http.*;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.RequestBuilder;
import org.apache.http.client.utils.HttpClientUtils;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.message.BasicHeader;
import org.apache.http.util.EntityUtils;

import java.net.SocketTimeoutException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;

public class HttpClient {

    private static final String RATE_LIMIT_RESET = "x-ratelimit-reset";
    private static final String RATE_LIMIT_LIMIT = "x-ratelimit-limit";
    private static final String RATE_LIMIT_REMAINING = "x-ratelimit-remaining";

    private static final String DEFAULT_USER_AGENT = "aftership-sdk-java/7.0.0 (https://www.aftership.com) apache-httpclient/4.5.14";
    protected final org.apache.http.client.HttpClient client;
    private final String domain;

    private RateLimit rateLimit;

    public HttpClient(final RequestConfig requestConfig, String userAgent, String domain) {
        this.domain = domain;
        if (userAgent == null || userAgent.isEmpty()) {
            userAgent = DEFAULT_USER_AGENT;
        }
        Collection<BasicHeader> headers = Arrays.asList(
                new BasicHeader(HttpHeaders.USER_AGENT, userAgent),
                new BasicHeader("aftership-client", DEFAULT_USER_AGENT),
                new BasicHeader(HttpHeaders.ACCEPT, "application/json"),
                new BasicHeader(HttpHeaders.ACCEPT_ENCODING, "utf-8"),
                new BasicHeader(HttpHeaders.CONTENT_TYPE, "application/json")
        );
        HttpClientBuilder clientBuilder = HttpClientBuilder.create();
        client = clientBuilder
                .setDefaultHeaders(headers)
                .setDefaultRequestConfig(requestConfig)
                .build();
    }

    public Response makeRequest(final Request request) throws Exception {
        HttpMethod method = request.getMethod();
        RequestBuilder builder = RequestBuilder.create(method.toString())
                .setUri(this.domain + request.getURL())
                .setVersion(HttpVersion.HTTP_1_1)
                .setCharset(StandardCharsets.UTF_8);
        for (Map.Entry<String, String> entry : request.getHeaders().entrySet()) {
            builder.addHeader(entry.getKey(), entry.getValue());
        }
        if (request.getBody() != null) {
            HttpEntity entity = new StringEntity(request.getBody(), ContentType.APPLICATION_JSON);
            builder.setEntity(entity);
        }
        HttpResponse response = null;
        try {
            response = client.execute(builder.build());
            HttpEntity entity = response.getEntity();
            return new Response(EntityUtils.toString(entity), response.getStatusLine().getStatusCode(), false);
        } finally {
            if (response != null) {
                HttpClientUtils.closeQuietly(response);
            }
        }
    }

    public Response request(final Request request, int retries) throws Exception {
        Response response = null;
        int i = 0;
        while (i <= retries) {
            try {
                i++;
                response = makeRequest(request);
                if (!shouldRetry(response)) {
                    break;
                }
            } catch (SocketTimeoutException e) {
                if (i > retries) {
                    throw new ApiException(0, ErrorEnum.TIMED_OUT.getMessage(), ErrorEnum.TIMED_OUT.getCode(), ErrorEnum.TIMED_OUT.getStatusCode(), e.getMessage());
                }
            }
            Thread.sleep(delay(i));
        }
        return response;
    }

    private boolean shouldRetry(Response response) {
        if (response.isTimeout()) {
            return true;
        }
        return response.getStatusCode() >= 500;
    }

    private int delay(int retryAttempt) {
        int delayBase = 3;
        int delay = delayBase * (2 ^ (retryAttempt - 1));
        double jitter = delay * (Math.random() - 0.5);
        return (int) (Math.max(1, delay + jitter) * 1000);
    }

    private void setRateLimiting(HttpResponse response) {
        if (response == null) {
            return;
        }
        RateLimit rateLimit = new RateLimit();
        Header limit = response.getFirstHeader(RATE_LIMIT_LIMIT);
        if (limit != null) {
            rateLimit.setLimit(Integer.parseInt(limit.getValue()));
        }
        Header reset = response.getFirstHeader(RATE_LIMIT_RESET);
        if (reset != null) {
            rateLimit.setReset(Long.parseLong(reset.getValue()));
        }
        Header remaining = response.getFirstHeader(RATE_LIMIT_REMAINING);
        if (remaining != null) {
            rateLimit.setRemaining(Integer.parseInt(remaining.getValue()));
        }
        this.rateLimit = rateLimit;
    }
}
